## Strukturalnie vs Obiektowo + Podstawy klas

2 g≈Ç√≥wne **paradygmaty** (sposoby my≈õlenia o kodzie). Dwa najwa≈ºniejsze to:
- **Programowanie strukturalne** - organizuje kod wok√≥≈Ç funkcji
- **Programowanie obiektowe** - organizuje kod wok√≥≈Ç obiekt√≥w

### Programowanie strukturalne

#### Czym jest?
Programowanie strukturalne to podej≈õcie, gdzie program dzielimy na mniejsze, logiczne bloki - **funkcje**. Ka≈ºda funkcja ma konkretne zadanie do wykonania.

#### G≈Ç√≥wne zasady:
- Kod pisany "od g√≥ry do do≈Çu" w logicznej kolejno≈õci
- Podzia≈Ç programu na funkcje
- Jasna struktura: sekwencja, wyb√≥r (if/else), pƒôtla

#### Przyk≈Çad - System ocen (strukturalnie)

```python
def dodaj_ocene(lista_ocen, nowa_ocena):
    lista_ocen.append(nowa_ocena)
    return lista_ocen

def oblicz_srednia(lista_ocen):
    if len(lista_ocen) == 0:
        return 0
    return sum(lista_ocen) / len(lista_ocen)

def sprawdz_zaliczenie(srednia):
    return srednia >= 3.0

def wyswietl_wynik(imie, srednia, zaliczyl):
    status = "ZALICZY≈Å" if zaliczyl else "NIE ZALICZY≈Å"
    print(f"{imie}: ≈õrednia {srednia:.2f} - {status}")

# G≈Ç√≥wny kod
imie_ucznia = "Jan Kowalski"
oceny_ucznia = []

dodaj_ocene(oceny_ucznia, 4)
dodaj_ocene(oceny_ucznia, 3)
dodaj_ocene(oceny_ucznia, 5)

srednia = oblicz_srednia(oceny_ucznia)
zaliczyl = sprawdz_zaliczenie(srednia)
wyswietl_wynik(imie_ucznia, srednia, zaliczyl)
```

### Programowanie obiektowe - podstawy

#### Czym jest?
Programowanie obiektowe to podej≈õcie, gdzie organizujemy kod wok√≥≈Ç **obiekt√≥w** - po≈ÇƒÖczenia danych (atrybut√≥w) i funkcji (metod), kt√≥re na tych danych operujƒÖ.

#### Kluczowe pojƒôcia:

**Klasa** - szablon opisujƒÖcy jak ma wyglƒÖdaƒá obiekt (jak przepis na ciasto)
**Obiekt** - konkretna instancja klasy (jak ciasto upieczone wed≈Çug przepisu)
**Atrybuty** - dane przechowywane w obiekcie (np. imiƒô ucznia)
**Metody** - funkcje nale≈ºƒÖce do obiektu

#### Przyk≈Çad - System ocen (obiektowo)

```python
class Uczen:    
    def __init__(self, imie):
        """Konstruktor - tworzy nowego ucznia"""
        self.imie = imie
        self.oceny = []
    
    def dodaj_ocene(self, ocena):
        if 1 <= ocena <= 6:
            self.oceny.append(ocena)
        else:
            print("Ocena musi byƒá z zakresu 1-6!")
    
    def oblicz_srednia(self):
        if len(self.oceny) == 0:
            return 0
        return sum(self.oceny) / len(self.oceny)
    
    def czy_zaliczyl(self):
        return self.oblicz_srednia() >= 3.0
    
    def wyswietl_wynik(self):
        srednia = self.oblicz_srednia()
        status = "ZALICZY≈Å" if self.czy_zaliczyl() else "NIE ZALICZY≈Å"
        print(f"{self.imie}: ≈õrednia {srednia:.2f} - {status}")

# U≈ºycie
jan = Uczen("Jan Kowalski")
anna = Uczen("Anna Nowak")

jan.dodaj_ocene(4)
jan.dodaj_ocene(3)
jan.dodaj_ocene(5)

anna.dodaj_ocene(5)
anna.dodaj_ocene(6)

jan.wyswietl_wynik()
anna.wyswietl_wynik()
```

### Schemat: Klasa vs Obiekt

```
    KLASA Uczen               OBIEKTY
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Atrybuty:       ‚îÇ      ‚îÇ jan:            ‚îÇ
    ‚îÇ - imie          ‚îÇ ‚îÄ‚îÄ‚Üí  ‚îÇ imie = "Jan"    ‚îÇ
    ‚îÇ - oceny         ‚îÇ      ‚îÇ oceny = [4,3,5] ‚îÇ
    ‚îÇ                 ‚îÇ      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚îÇ Metody:         ‚îÇ      
    ‚îÇ - dodaj_ocene() ‚îÇ      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ - oblicz_srednia‚îÇ ‚îÄ‚îÄ‚Üí  ‚îÇ anna:           ‚îÇ
    ‚îÇ - wyswietl_wynik‚îÇ      ‚îÇ imie = "Anna"   ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ oceny = [5,6]   ‚îÇ
                             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### üéØ ZADANIA DO WYKONANIA

**Zadanie 1**: Stw√≥rz klasƒô `Samochod` z atrybutami: marka, model, przebieg. Dodaj metody: `jedz(kilometry)`, `sprawdz_przebieg()`.

**Zadanie 2**: Stw√≥rz klasƒô `Kalkulator` z metodami: `dodaj()`, `odejmij()`, `pomnoz()`, `podziel()`.

---

## Enkapsulacja - ukrywanie danych

### Czym jest enkapsulacja?
Enkapsulacja to **ukrywanie wewnƒôtrznych szczeg√≥≈Ç√≥w** obiektu przed ≈õwiatem zewnƒôtrznym. U≈ºytkownik mo≈ºe korzystaƒá tylko z publicznych metod, ale nie ma bezpo≈õredniego dostƒôpu do danych.

### Po co ukrywaƒá dane?
- **Bezpiecze≈Ñstwo** - zapobiegamy przypadkowemu zepsuciu danych
- **Kontrola** - wymuszamy prawid≈Çowy spos√≥b u≈ºywania obiektu
- **≈Åatwiejsze zmiany** - mo≈ºemy zmieniƒá implementacjƒô bez wp≈Çywu na resztƒô kodu

### Poziomy dostƒôpu w Pythonie:

#### 1. Publiczne (brak oznacze≈Ñ) - ka≈ºdy ma dostƒôp
```python
self.imie = "Jan"  # Ka≈ºdy mo≈ºe czytaƒá i zmieniaƒá
```

#### 2. Chronione (jedno podkre≈õlenie `_`) - sygna≈Ç ostrzegawczy
```python
self._oceny = []  # Sygna≈Ç: "nie ruszaj tego bezpo≈õrednio!"
```

#### 3. Prywatne (dwa podkre≈õlenia `__`) - naprawdƒô ukryte
```python
self.__pin = "1234"  # Bardzo trudno dostƒôpne z zewnƒÖtrz
```

### Przyk≈Çad - Konto bankowe

```python
class KontoBankowe:
    def __init__(self, wlasciciel, saldo_poczatkowe):
        # PUBLICZNE - ka≈ºdy mo≈ºe to zobaczyƒá
        self.wlasciciel = wlasciciel
        
        # CHRONIONE - nie ruszaj bezpo≈õrednio!
        self._numer_konta = "123456789"
        self._historia = []
        
        # PRYWATNE - naprawdƒô ukryte!
        self.__saldo = saldo_poczatkowe
        self.__pin = "1234"
    
    # Jedyny spos√≥b dostƒôpu do prywatnych danych
    def wplac(self, kwota):
        if kwota > 0:
            self.__saldo += kwota
            self._historia.append(f"Wp≈Çata: {kwota}")
            print(f"Wp≈Çacono {kwota} z≈Ç")
        else:
            print("Kwota musi byƒá dodatnia!")
    
    def wyplac(self, kwota, pin):
        if pin != self.__pin:
            print("B≈Çƒôdny PIN!")
            return
        
        if 0 < kwota <= self.__saldo:
            self.__saldo -= kwota
            self._historia.append(f"Wyp≈Çata: {kwota}")
            print(f"Wyp≈Çacono {kwota} z≈Ç")
        else:
            print("NiewystarczajƒÖce ≈õrodki!")
    
    def sprawdz_saldo(self, pin):
        if pin != self.__pin:
            print("B≈Çƒôdny PIN!")
            return None
        return self.__saldo

# PRAWID≈ÅOWE U≈ªYCIE
konto = KontoBankowe("Jan Kowalski", 1000)
konto.wplac(500)
print(f"Saldo: {konto.sprawdz_saldo('1234')}")

# NIEPRAWID≈ÅOWE - ≈Çamanie enkapsulacji
# konto._saldo = 999999  # ≈πLE! Mo≈ºna to zrobiƒá, ale nie powinno siƒô!
```

### Por√≥wnanie: Co mo≈ºna robiƒá z r√≥≈ºnymi poziomami

```python
konto = KontoBankowe("Jan Kowalski", 1000)

# PUBLICZNE - bez problemu
print(konto.wlasciciel)        # ‚úì Dzia≈Ça
konto.wlasciciel = "Anna"      # ‚úì Mo≈ºna zmieniƒá

# CHRONIONE - mo≈ºna, ale nie powinno siƒô
print(konto._numer_konta)      # ‚ö†Ô∏è Dzia≈Ça, ale to sygna≈Ç "nie r√≥b tego"
konto._historia.append("test") # ‚ö†Ô∏è Mo≈ºna, ale ≈Çamie zasady

# PRYWATNE - Python blokuje dostƒôp
# print(konto.__saldo)         # ‚ùå B≈ÅƒÑD! AttributeError
# konto.__pin = "9999"         # ‚ùå B≈ÅƒÑD! Nie mo≈ºna zmieniƒá

# PRAWID≈ÅOWY dostƒôp do prywatnych danych - przez metody
konto.wplac(500)                           # ‚úì Kontrolowane
print(f"Saldo: {konto.sprawdz_saldo('1234')}")  # ‚úì Bezpieczne
```

### üéØ ZADANIA DO WYKONANIA 

**Zadanie 3**: Popraw klasƒô `Samochod` z poprzedniej lekcji - ukryj przebieg i dodaj metodƒô `dodaj_kilometry()` z walidacjƒÖ (tylko dodatnie warto≈õci).

**Zadanie 4**: Stw√≥rz klasƒô `Telefon` z ukrytym numerem PIN i metodami: `odblokuj(pin)`, `zablokuj()`, `dzwon(numer)` (tylko gdy odblokowany).

---

## Dziedziczenie - klasy potomne

### Czym jest dziedziczenie?
Dziedziczenie pozwala tworzyƒá nowe klasy **na podstawie ju≈º istniejƒÖcych**. Klasa potomna dziedziczy wszystkie atrybuty i metody z klasy rodzica, ale mo≈ºe je rozszerzyƒá lub zmieniƒá.

### Terminologia:
- **Klasa rodzic** (bazowa) - klasa, z kt√≥rej dziedziczymy
- **Klasa potomek** (pochodna) - klasa dziedziczƒÖca

### Co dziedziczy klasa potomek?
1. Wszystkie atrybuty klasy rodzica
2. Wszystkie metody klasy rodzica
3. Mo≈ºe dodaƒá nowe atrybuty i metody
4. Mo≈ºe zmieniƒá (nadpisaƒá) metody rodzica

### Przyk≈Çad - System szkolny

```python
# KLASA RODZIC - wsp√≥lne cechy wszystkich os√≥b w szkole
class Osoba:
    def __init__(self, imie, nazwisko, wiek):
        self.imie = imie
        self.nazwisko = nazwisko
        self.wiek = wiek
    
    def przedstaw_sie(self):
        print(f"Jestem {self.imie} {self.nazwisko}, mam {self.wiek} lat")
    
    def wejdz_do_szkoly(self):
        print(f"{self.imie} wszed≈Ç do szko≈Çy")

# KLASA POTOMEK - Ucze≈Ñ dziedziczy wszystko z Osoba + dodaje swoje
class Uczen(Osoba):  # ‚Üê Dziedziczenie!
    def __init__(self, imie, nazwisko, wiek, klasa):
        # Wywo≈Çujemy konstruktor rodzica
        super().__init__(imie, nazwisko, wiek)
        # Dodajemy nowe atrybuty
        self.klasa = klasa
        self.oceny = []
    
    # NADPISUJEMY metodƒô z rodzica
    def przedstaw_sie(self):
        print(f"Jestem {self.imie} {self.nazwisko}, ucze≈Ñ klasy {self.klasa}")
    
    # DODAJEMY nowe metody
    def dodaj_ocene(self, ocena):
        self.oceny.append(ocena)

# KLASA POTOMEK - Nauczyciel te≈º dziedziczy z Osoba
class Nauczyciel(Osoba):
    def __init__(self, imie, nazwisko, wiek, przedmiot):
        super().__init__(imie, nazwisko, wiek)
        self.przedmiot = przedmiot
        self._pensja = 5000  # Prywatne!
    
    def przedstaw_sie(self):
        print(f"Jestem {self.imie} {self.nazwisko}, nauczyciel {self.przedmiot}")
    
    def sprawdz_pensje(self):
        return self._pensja

# U≈ºycie
uczen = Uczen("Jan", "Kowalski", 16, "3A")
nauczyciel = Nauczyciel("Anna", "Nowak", 35, "matematyka")

# Wszyscy mogƒÖ u≈ºywaƒá metod z klasy Osoba
uczen.wejdz_do_szkoly()        # Odziedziczona metoda
nauczyciel.wejdz_do_szkoly()   # Odziedziczona metoda

# Ka≈ºdy ma swojƒÖ wersjƒô przedstaw_sie()
uczen.przedstaw_sie()      # "Jestem Jan Kowalski, ucze≈Ñ klasy 3A"
nauczyciel.przedstaw_sie() # "Jestem Anna Nowak, nauczyciel matematyka"

# Tylko ucze≈Ñ mo≈ºe dodawaƒá oceny
uczen.dodaj_ocene(5)
```

### Schemat dziedziczenia:

```
           Osoba
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ           ‚îÇ
    Uczen    Nauczyciel
              ‚îÇ
          Dyrektor
```

### Wielopoziomowe dziedziczenie

```python
# Dyrektor dziedziczy po Nauczycielu (kt√≥ry dziedziczy po Osoba)
class Dyrektor(Nauczyciel):
    def __init__(self, imie, nazwisko, wiek, lata_stazu):
        super().__init__(imie, nazwisko, wiek, "zarzƒÖdzanie")
        self.lata_stazu = lata_stazu
        self._pensja = 8000  # Wy≈ºsza pensja
    
    def przedstaw_sie(self):
        print(f"Jestem {self.imie} {self.nazwisko}, dyrektor ({self.lata_stazu} lat sta≈ºu)")
    
    def zwolaj_rade(self):
        print("Zwo≈Çujƒô radƒô pedagogicznƒÖ!")

dyrektor = Dyrektor("Piotr", "Wi≈õniewski", 50, 20)

# Dyrektor mo≈ºe wszystko co Nauczyciel i Osoba:
dyrektor.wejdz_do_szkoly()    # Z Osoba
dyrektor.sprawdz_pensje()     # Z Nauczyciel  
dyrektor.zwolaj_rade()        # W≈Çasna metoda
```

### üéØ ZADANIA DO WYKONANIA 

**Zadanie 5**: Stw√≥rz klasƒô `Pojazd` z atrybutami: marka, rok_produkcji, metoda `jedz()`. Nastƒôpnie stw√≥rz klasy potomne: `Samochod` (dodaj: liczba_drzwi) i `Motocykl` (dodaj: typ_silnika).

**Zadanie 6**: Rozszerz system szkolny - dodaj klasƒô `Wychowawca` dziedziczƒÖcƒÖ po `Nauczyciel` z metodƒÖ `sprawdz_frekwencje()`.

---

## Por√≥wnanie podej≈õƒá - Podsumowanie

| Aspekt | Programowanie strukturalne | Programowanie obiektowe |
|--------|---------------------------|------------------------|
| **Organizacja** | Funkcje + dane oddzielnie | Dane i metody razem |
| **Trudno≈õƒá** | ≈Åatwiejsze na poczƒÖtku | Trudniejsze na poczƒÖtku |
| **Ma≈Çe programy** | WystarczajƒÖce ‚úì | Mo≈ºe byƒá przesadƒÖ |
| **Du≈ºe projekty** | Trudne do zarzƒÖdzania | ≈Åatwiejsze ‚úì |
| **Ponowne u≈ºycie** | Ograniczone | Lepsze ‚úì |
| **Zespo≈Çowa praca** | Trudniejsza | ≈Åatwiejsza ‚úì |

## Kiedy u≈ºywaƒá kt√≥rego podej≈õcia?

### U≈ºyj programowania strukturalnego gdy:
- Piszesz ma≈Çe, proste programy (do 200 linii)
- RozwiƒÖzujesz jednorazowy problem
- Program ma prostƒÖ, liniowƒÖ logikƒô

### U≈ºyj programowania obiektowego gdy:
- Piszesz wiƒôkszy program (>200 linii)
- Program bƒôdzie rozwijany przez d≈Çu≈ºszy czas
- Pracujesz w zespole
- Modelujesz rzeczywiste obiekty (osoby, pojazdy, produkty)

## Czƒôste b≈Çƒôdy

‚ùå **Tworzenie klasy (gdy wystarczy funkcja)**
```python
# ≈πLE - niepotrzebna klasa
class Dodawanie:
    def dodaj(self, a, b):
        return a + b

# DOBRZE - wystarczy funkcja
def dodaj(a, b):
    return a + b
```

‚ùå **Mylenie klasy z obiektem**
```python
# ≈πLE - pr√≥ba wywo≈Çania metody na klasie
Uczen.dodaj_ocene(5)

# DOBRZE - wywo≈Çanie na obiekcie
jan = Uczen("Jan", "Kowalski", 16, "3A")
jan.dodaj_ocene(5)
```

‚ùå **Robienie wszystkiego publicznym**
```python
# ≈πLE - brak enkapsulacji
class Konto:
    def __init__(self):
        self.saldo = 1000  # Ka≈ºdy mo≈ºe to zmieniƒá!

# LEPIEJ - kontrola dostƒôpu
class Konto:
    def __init__(self):
        self._saldo = 1000  # Sygna≈Ç: nie zmieniaj bezpo≈õrednio
```

---

**Dobry programista powinien znaƒá oba podej≈õcia i umieƒá wybraƒá odpowiednie do sytuacji!**
